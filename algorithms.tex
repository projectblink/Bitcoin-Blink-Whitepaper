\documentclass[a4paper,10pt,twocolumn]{extarticle}
\usepackage[a4paper , top=10mm, right=10mm,left=10mm, bottom=10mm]{geometry}
\usepackage{nopageno}
\thispagestyle{empty}
\usepackage{geometry}
\usepackage{amsmath} % for math and equations
\usepackage{amssymb} % for symbols
\usepackage[boxruled]{algorithm2e} %algorithm
\usepackage{algorithmicx} %algorithm
\usepackage{algpseudocode}
%declarations
\algnewcommand{\algorithmicand}{\textbf{ and }}
\algnewcommand{\algorithmicor}{\textbf{ or }}
\algnewcommand{\OR}{\algorithmicor}
\algnewcommand{\AND}{\algorithmicand}
\algnewcommand{\var}{\texttt}
\usepackage{comment}
\usepackage{color}
\usepackage{float}
\usepackage{hyperref}
\SetAlCapNameFnt{\scriptsize}
\SetAlCapFnt{\scriptsize}

%Algorithm2e Declarations
\SetKwProg{Fn}{Function}{ is}{end}


\SetKwInput{KwInput}{Input} % Set the Input
\SetKwInput{KwOutput}{Output} % set the Output
\SetKwInput{KwPre}{pre} % Set the Pre
\SetKwInput{KwPost}{post} % set the Post


\definecolor{pagecolor}{rgb}{1,0.98,0.9}


\title{\vspace{-10mm} \scriptsize \textbf{REFERENCE ALGORITHMS} \vspace{3mm}\\
\scriptsize \vspace{-2mm} Purva Choudhari\thanks{https://github.com/Purva-Chaudhari}, Ajay Joshua\thanks{https://github.com/I-Corinthian}\vspace{-14mm}}
\date{\scriptsize \today \hspace{0.5mm} (Updated) \vspace{-5mm}}

\algnewcommand\Signal{\textbf{signal}}
\begin{document}


\maketitle
\scriptsize

\noindent Individual Hash-rate zk-Circuit

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\SetKwInput{KwSigIn}{signal input} % set the Signal Input
\SetKwInput{KwSigOut}{signal output} % set the Signal Input

\tcc{Public signals}
\KwSigIn{node\_ihr}
\KwSigIn{ihr\_hash}
\tcc{Private signals}
\KwSigIn{salt}
\KwSigIn{required\_ihr}
\tcc{Output signal}
\KwSigOut{if\_pass}
\tcc{Range proof check}
\textbf{signal}  buffer\;
\textbf{signal}  range\_check\;
\If{node\_ihr $>$ required\_ihr - buffer \AND node\_ihr $<$ required\_ihr + buffer} {range\_check = true\;}
\tcc{Verify hash}
\textbf{signal}  hash\;
\textbf{signal}  hash\_check\;
\tcc{RIPEMD160 to calculate the hash}
hash = RIPEMD160 (salt, required\_ihr)\;
\If{hash == ihr\_hash} {hash\_check = true\;}
\uIf{range\_check \&\& hash\_check} {if\_pass = true\;}
\Else{if\_pass = false\;}
\tcc{Bandwidth circuit $\equiv$ IHR circuit}
\caption{ZK IHR Circuit}
\end{algorithm}

\noindent Tax Script

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\SetKwInput{KwKey}{Key} % Set the Key
\SetKwFunction{Fspend}{spend}
\SetKwProg{Func}{Function}{:}{{end}}
\caption{Tax Script}

\KwKey{signature, amount, current\_exchange\_rate preimage\_of\_signature}
\KwOut{updated stateful contract for the sender \& new stateful contract for the receiver}
\Begin {

DataLen = 1\;

amount = 0\;

pubKey = null\;

exchange\_rate = 0\;

tds = 0\;

	\Func {\Fspend(sig, amount, current\_exchange\_rate, preimage)}{

		\If{checkSig(sig, pubKey) \AND Tx.checkPreimage(preimage)}{

			scriptCode \gets SigHash.scriptCode(preimage)\;

			codeend \gets \text{position where the opcode ends}\;

			codepart \gets scriptCode[:codeend]\;

			sender \gets  PubKey(scriptCode[codeend+DataLen+1):(codeend+DataLen+1)+Constants.PubKeyLen])\;

			gains \gets (amount * current\_exchange\_rate) - (amount * exchange\_rate)\;

				\If {gains $>$ 0 }{
 
					 amount \gets amount - (gains*(30/100))*(current\_exchange\_rate)\;

}

				\If {amount \leq (amount - tds) \AND sender == pubKey \AND amount \geq 0}{

					 amount \gets amount - amount\;
 
					}

			}
	}
}
\end{algorithm}

\scriptsize \noindent Merkle Chain

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\KwPre{the snip is added to the data}
\KwPost{the data is added to the chain}
\Begin{
 add\_node(snip)\;
 d $\gets$ snip\;
  \uIf{head = null}{
    head,tail $\gets$ add\_data(d)\;}
    \Else {tail $\gets$ add\_data(d)\;}
    }
\scriptsize
\caption{class MerkleChain}
\end{algorithm}


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\KwPre{the value is added to the vector}
\KwPost{the vector is generated to a merkle tree and added to the chain}
\Begin {
New Vector data\;
data $\gets$ d\;
\If{size(data) == max\_block\_size}
{generate\_root(data)}
}
\caption{class add\_data(d)}
\end{algorithm}






\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\KwPre{the vector data is added as the leaves}
\KwPost{merkel tree and its root is generated }
\Begin{
New Vector temp\_data\;
temp\_data $\gets$ data\;
\While {temp\_data $>$ 1}{
\For{i = 0  i $<$ size(temp\_data)  i+2}{
Left $\gets$ temp\_data[i]\;
Right $\gets$ (i+1 == size(temp\_data)) ? temp\_data[i] : temp\_data[i+1]\;
combined = Left + Right \;
new\_temp\_data $\gets$ hash(combined)\;
}
temp\_data $\gets$ new\_temp\_data\;
}
node\_root $\gets$ temp\_data[0]\;
}
\caption{generate\_root()}
\end{algorithm}


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\SetKwInput{KwInitialized}{initialized} % set the Initialized
\KwInitialized{chain is an object of class MerkleChain and  string data}
\Begin{
\While {true}
{Output “enter data (q to quit)”
Get data\;
\If {data = q}
{ 
Break\;
\Else {
addnode(data)\;}
      }
     }
     }
 \caption{main()}
\end{algorithm}


\begin{comment}


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Node Weights}
Algo\;
%Scan the blockchain for node join script with bandwidth x, weight 0
%Scan from genesis block to current block
% Add weight and store in temp in node itself
%If Sucessful block add weight by 0.0001*block size limit per sec
%If unsucessful block without fee snip add weight -0.02* block size limit per sec
%If Fork Proof provided add weight to the prover node +0.01 *block size limit per sec and add weight to the forker -0.01 * block size limit per sec 
%Loop it after every block is added
\end{algorithm}


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
Algo\;
% If block time is over or block size is capped or end snip received, add block to chain
% Update block by receiving last blocks updated hash proof
% If new proof of block n is heavy than old proof, update the block % Find the snips to remove by linearly hashing one by one snip and when the MCR output = new proof MCR output then reject remaining snips
% Update the block and add to chain
% Add the next new block now to the chain
% Calculate the ring size after a block is received and confirmed by next block
% Ring size > 1 < no of nodes in node join req
% If the confirmed block is forked then, reduce ring size by 1 int, end election
% If the confirmed block is not forked, add ring size by 1 int, which denotes two tails should be elected
% Set the ring size in int
% From all node joining scripts make a set A of bandwidths descending
% Remove current ring validators from it
% From all node joining scripts make a set B of with updated weights in descending
% remove current ring validators from it
%From previous ring validators of previous block calculate the mean value >= 0
% set the mean value as ring tail join requirement
% Current head shall calculate the h by MCR of the block + Linear Hash of Hash Proofs
% Set h as K
% Update set A by > join req
% Update set B by choosing set A pubkeys only
% Order set B by descending
% Find 2 pubkeys of MD160 hash in set B which is lesser than K
% If no Find 2 pubkeys of MD160 hash in set B which is greater than K
% When the pubkey is found
% Find their bandwidth from their node joining script
% Take the median value from it and keep it as block size limit per sec
% Now we have to find per block time to find per block size
%Take ring size number of blocks
%For new upcoming n block find the block time
% using ring size take all the previous block
% Find the median of it = block time
% From the block time, find the per block size
% give block size in bits / sec and block time in global hashes
% from block time global hashes calculate the individual block time count using its IHR
% Set a cap that not more than the individual block time the producer should produce
\caption{Snip Construction}
\end{algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Hash Proofing}
Algo\;
%Hashclock (single thread hashing) start with first snip arrival
%Rebuild the ring validators for the block
%From ring validators rebuild the block size and individual time in hash counts
%Snip + Preimage + Signature attach for the hash that produces from concatenating
%Send to next instructed node on the routing instruction
% If ind block time finish stop accepting snips and add that as block
% If block size is exceeding reject snips and add that as block
\end{algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Hash Reward}
% Calculate Total hashes H and Total bitcoins g remaining for the halving period

% Per hash reward from total hash count (total sec * legacy hashrate) till next halve will have g bitcoins, if fork slash, if not rest counts will be added to g, Per hash reward = g/total remaining count
\end{algorithm}

Tokens should be traded for bitcoins inorder for nodes to fix its market price which will assist in facilitating its transactions, per block stake requirement, non-accepted token producer commission, etc as every procedure follows up with denominations in bitcoin. For regulators they can select a specific any token id, can also possibly be their fiat currency as a L1 token on bitcoin for taxing oppurtunities on profits (capital gains). A token map is drawn 


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Transfer and renting fees}
% Transfer Fee
\end{algorithm}


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Staking}
% Finiding the requirement per token per block
% Direct commission, deposit to script, ct inflation
\end{algorithm}


\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Swap Script}
% Two token swap with conditions
\end{algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{Exchange Rate}
% Nodes find exchange rate and accepting script state update, script update unlock after x blocks - ring validator
\end{algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\scriptsize
\DontPrintSemicolon
\caption{DAO Contracts}
% Adding contracts
% Contracts withdrawal by proving
% Paying dividend according to weightage
% Removing contracts and temp membership
\end{algorithm}

\end{comment}

\end{document}

