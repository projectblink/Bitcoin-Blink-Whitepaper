\documentclass[a4paper,10pt,twocolumn]{extarticle}
\usepackage[a4paper , top=8mm, right=8mm,left=8mm, bottom=8mm]{geometry}
\usepackage{nopageno}
\thispagestyle{empty}
\usepackage{geometry}
\usepackage{amsmath} % for math and equations
\usepackage{amssymb} % for symbols
\usepackage[boxruled,lined]{algorithm2e} %algorithm
\usepackage{algorithmicx} %algorithm
\usepackage{algpseudocode}
%declarations
\algnewcommand{\algorithmicand}{\textbf{ and }}
\algnewcommand{\algorithmicor}{\textbf{ or }}
\algnewcommand{\OR}{\algorithmicor}
\algnewcommand{\AND}{\algorithmicand}
\algnewcommand{\var}{\texttt}
\usepackage{comment}
\usepackage{color}
\usepackage{float}
\usepackage{hyperref}
\SetAlCapNameFnt{\scriptsize}
\SetAlCapFnt{\scriptsize}

%Algorithm2e Declarations
\SetKwProg{Fn}{Function}{ is}{end}


\SetKwInput{KwInput}{Input} % Set the Input
\SetKwInput{KwOutput}{Output} % set the Output
\SetKwInput{KwPre}{pre} % Set the Pre
\SetKwInput{KwPost}{post} % set the Post


\definecolor{pagecolor}{rgb}{1,0.98,0.9}


\title{\vspace{-10mm} \footnotesize \textbf{REFERENCE ALGORITHMS} \vspace{3mm}\\
\scriptsize \vspace{-2mm} Purva Choudhari\thanks{https://github.com/Purva-Chaudhari}, Ajay Joshua\thanks{https://github.com/I-Corinthian} \vspace{1mm}\\
\url{https://github.com/projectblink}\vspace{-14mm}}
\date{\scriptsize \today \hspace{0.5mm} (Genesis Version) \vspace{-7mm}}

\algnewcommand\Signal{\textbf{signal}}
\begin{document}
\maketitle
\scriptsize
\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Network Graph \& Path Finding}
Algo\;
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Onion Peeling}
Algo\;
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Node Weights}
Algo\;
%Scan the blockchain for node join script with bandwidth x, weight 0
%Scan from genesis block to current block
% Add weight and store in temp in node itself
%If Sucessful block add weight by 0.0001*block size limit per sec
%If unsucessful block without fee snip add weight -0.02* block size limit per sec
%If Fork Proof provided add weight to the prover node +0.01 *block size limit per sec and add weight to the forker -0.01 * block size limit per sec 
%Loop it after every block is added
\end{algorithm}


\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
Algo\;
% If block time is over or block size is capped or end snip received, add block to chain
% Update block by receiving last blocks updated hash proof
% If new proof of block n is heavy than old proof, update the block % Find the snips to remove by linearly hashing one by one snip and when the MCR output = new proof MCR output then reject remaining snips
% Update the block and add to chain
% Add the next new block now to the chain
% Calculate the ring size after a block is received and confirmed by next block
% Ring size > 1 < no of nodes in node join req
% If the confirmed block is forked then, reduce ring size by 1 int, end election
% If the confirmed block is not forked, add ring size by 1 int, which denotes two tails should be elected
% Set the ring size in int
% From all node joining scripts make a set A of bandwidths descending
% Remove current ring validators from it
% From all node joining scripts make a set B of with updated weights in descending
% remove current ring validators from it
%From previous ring validators of previous block calculate the mean value >= 0
% set the mean value as ring tail join requirement
% Current head shall calculate the h by MCR of the block + Linear Hash of Hash Proofs
% Set h as K
% Update set A by > join req
% Update set B by choosing set A pubkeys only
% Order set B by descending
% Find 2 pubkeys of MD160 hash in set B which is lesser than K
% If no Find 2 pubkeys of MD160 hash in set B which is greater than K
% When the pubkey is found
% Find their bandwidth from their node joining script
% Take the median value from it and keep it as block size limit per sec
% Now we have to find per block time to find per block size
%Take ring size number of blocks
%For new upcoming n block find the block time
% using ring size take all the previous block
% Find the median of it = block time
% From the block time, find the per block size
% give block size in bits / sec and block time in global hashes
% from block time global hashes calculate the individual block time count using its IHR
% Set a cap that not more than the individual block time the producer should produce
\caption{Snip Construction}
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Hash Proofing}
Algo\;
%Hashclock (single thread hashing) start with first snip arrival
%Rebuild the ring validators for the block
%From ring validators rebuild the block size and individual time in hash counts
%Snip + Preimage + Signature attach for the hash that produces from concatenating
%Send to next instructed node on the routing instruction
% If ind block time finish stop accepting snips and add that as block
% If block size is exceeding reject snips and add that as block
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Hash Reward}
% Calculate Total hashes H and Total bitcoins g remaining for the halving period
% Per hash reward from total hash count (total sec * legacy hashrate) till next halve will have g bitcoins, if fork slash, if not rest counts will be added to g, Per hash reward = g/total remaining count
\end{algorithm}
\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\SetKwInput{KwSigIn}{signal input} % set the Signal Input
\SetKwInput{KwSigOut}{signal output} % set the Signal Input

\tcc{Public signals}
\KwSigIn{node\_ihr}
\KwSigIn{ihr\_hash}
\tcc{Private signals}
\KwSigIn{salt}
\KwSigIn{required\_ihr}
\tcc{Output signal}
\KwSigOut{if\_pass}
\tcc{Range proof check}
\textbf{signal}  buffer\;
\textbf{signal}  range\_check\;
\If{node\_ihr $>$ required\_ihr - buffer \AND node\_ihr $<$ required\_ihr + buffer} {range\_check = true\;}
\tcc{Verify hash}
\textbf{signal}  hash\;
\textbf{signal}  hash\_check\;
\tcc{RIPEMD160 to calculate the hash}
hash = RIPEMD160 (salt, required\_ihr)\;
\If{hash == ihr\_hash} {hash\_check = true\;}
\uIf{range\_check \&\& hash\_check} {if\_pass = true\;}
\Else{if\_pass = false\;}
\tcc{Bandwidth circuit $\equiv$ IHR circuit}
\caption{ZK IHR Circuit}
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\SetKwInput{KwKey}{Key} % Set the Key
\SetKwFunction{Fspend}{spend}
\SetKwProg{Func}{Function}{:}{{end}}
\caption{Tax Script}
\KwKey{signature, amount, current\_exchange\_rate, preimage\_of\_signature, tax\_percent}
\KwOut{updated stateful contract for the sender & new stateful contract for the receiver}
\Begin{
	DataLen = 1\;
	utxo\_amount \gets initial\_amount\;
	
	pubKey \gets \text{pubkey of the sender}\;
	
	exchange\_rate \gets initial\_exchange\_rate\;
	
	tds \gets TDS \;

	\Func {\Fspend(sig, amount, current\_exchange\_rate, tax\_percent, receiver\_pubkey,preimage)}
		{

		\If{checkSig(sig, pubKey) \AND Tx.checkPreimage(preimage)}
			{

			scriptCode \gets SigHash.scriptCode(preimage)\;

			codeend \gets \text{position where the opcode ends}\;

			codepart \gets scriptCode[:codeend]\;

			gains \gets (amount * current\_exchange\_rate) - (amount * exchange\_rate)\;

			\If {gains $>$ 0}
				{

					amount \gets amount - (gains*(tax\_percent/100))*(current\_exchange\_rate)\;

					\If {amount \leq (amount - tds) \AND sender == pubKey \AND amount \geq 0}
						{

						utxo\_amount \gets utxo\_amount - amount\; 
						} 
				}
					
			updated\_script \gets codepart+utxo\_amount+sender+current\_exchange\_rate+tds\;				 

			new\_script \gets codepart+utxo\_amount+receiver\_pubkey+current\_exchange\_rate+tds\;
   
			hash \gets sha256(updated\_script+new\_script)\;    
  
			\If{hash == SigHash.hashOutputs(preimage)}
				{  
				TRUE\; 
}
}
}
}
\end{algorithm}

\begin{algorithm}
\scriptsize
\DontPrintSemicolon
class MerkleChain\;
\KwPre{the snip is added to the data}
\KwPost{the data is added to the chain}
\Begin{
 add\_node(snip)\;
 d $\gets$ snip\;
  \uIf{head = null}{
    head,tail $\gets$ add\_data(d)\;}
    \Else {tail $\gets$ add\_data(d)\;}
    }

\hrulefill

class add\_data(d)\;
\KwPre{the value is added to the vector}
\KwPost{the vector is generated to a merkle tree and added to the chain}
\Begin {
New Vector data\;
data $\gets$ d\;
\If{size(data) == max\_block\_size}
{generate\_root(data)}
}

\hrulefill

generate\_root()\;
\KwPre{the vector data is added as the leaves}
\KwPost{merkel tree and its root is generated }
\Begin{
New Vector temp\_data\;
temp\_data $\gets$ data\;
\While {temp\_data $>$ 1}{
\For{i = 0  i $<$ size(temp\_data)  i+2}{
Left $\gets$ temp\_data[i]\;
Right $\gets$ (i+1 == size(temp\_data)) ? temp\_data[i] : temp\_data[i+1]\;
combined = Left + Right \;
new\_temp\_data $\gets$ hash(combined)\;
}
temp\_data $\gets$ new\_temp\_data\;
}
node\_root $\gets$ temp\_data[0]\;
}

\hrulefill

main()\;
\SetKwInput{KwInitialized}{initialized} % set the Initialized
\KwInitialized{chain is an object of class MerkleChain and  string data}
\Begin{
\While {true}
{Output “enter data (q to quit)”
Get data\;
\If {data = q}
{ 
Break\;
\Else {
addnode(data)\;}
      }
     }
     }

\caption{Merkle Chain}
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Open Order Swap Script}
% Two token swap with conditions
\end{algorithm}

\begin{algorithm}[H]

\scriptsize
\DontPrintSemicolon
\caption{Exchange Rate Calculation}
% Calculate mid_market_price = (highest ask + lowest bid)/2 for every token pair for every x blocks
%Make a graph of pairs
% If Token has direct connection with bitcoin as a pair fix that mid_market_price of pair as exchange rate of the token
% If no direct connection then find the shortest path of pair connecting to bitcoin
	% Update the exchange rate of the token
% If not connected to bitcoin, make exchange_rate as invalid, so transaction invalid
% For bitcoin take all the pair's exchange rate, and calculate the weighted average move according to each pairs volume.
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Staking Script}
Algo\;
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{DAO Contracts}
% Adding contracts
% Contracts withdrawal by proving
% Paying dividend according to weightage
% Removing contracts and temp membership
\end{algorithm}

\begin{algorithm}[H]
\scriptsize
\DontPrintSemicolon
\caption{Token Minting Procedure}
\end{algorithm}

\begin{algorithm}[H]

\tcc{Transfer and renting fees can only be deployed after a stable algorithm is written.}
\scriptsize
\DontPrintSemicolon
\caption{Transfer and renting fees}
\end{algorithm}

\end{document}

